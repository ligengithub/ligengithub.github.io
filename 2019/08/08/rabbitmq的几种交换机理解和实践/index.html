<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>rabbitmq的几种交换机理解实践 | 一朵野花</title><meta name="description" content="rabbitmq的几种交换机理解实践"><meta name="keywords" content="rabbitmq"><meta name="author" content="一朵野花"><meta name="copyright" content="一朵野花"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/08/08/rabbitmq的几种交换机理解和实践/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="rabbitmq的几种交换机理解实践"><meta name="twitter:description" content="rabbitmq的几种交换机理解实践"><meta name="twitter:image" content="https://i.loli.net/2019/09/26/IvUxnfrh86kG7Oa.jpg"><meta property="og:type" content="article"><meta property="og:title" content="rabbitmq的几种交换机理解实践"><meta property="og:url" content="http://yoursite.com/2019/08/08/rabbitmq的几种交换机理解和实践/"><meta property="og:site_name" content="一朵野花"><meta property="og:description" content="rabbitmq的几种交换机理解实践"><meta property="og:image" content="https://i.loli.net/2019/09/26/IvUxnfrh86kG7Oa.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="spring Cloud 的Hystrix" href="http://yoursite.com/2019/08/19/springCloud的hystrix和状态监控/"><link rel="next" title="Zookeeper的分布式锁" href="http://yoursite.com/2019/07/27/Zookeeper分布式锁/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#交换机"><span class="toc-number">1.</span> <span class="toc-text">交换机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel与Connection"><span class="toc-number">2.</span> <span class="toc-text">Channel与Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重点总结："><span class="toc-number">2.0.1.</span> <span class="toc-text">重点总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1、几种交换机的效率以及特点"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">1、几种交换机的效率以及特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-消息监听的两种方式"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">2 消息监听的两种方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3、两个类-RabbitTemplate-和RabbitAdmin"><span class="toc-number">2.0.1.0.3.</span> <span class="toc-text">3、两个类 RabbitTemplate 和RabbitAdmin</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4、一个生产者对应多个消费者"><span class="toc-number">2.0.1.0.4.</span> <span class="toc-text">4、一个生产者对应多个消费者</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5、-总之-ranbbitmq四个步骤"><span class="toc-number">2.0.1.0.5.</span> <span class="toc-text">5、 总之 ranbbitmq四个步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息的延时"><span class="toc-number">2.0.2.</span> <span class="toc-text">消息的延时</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-队列ttl-单条消息ttl"><span class="toc-number">2.0.2.0.1.</span> <span class="toc-text">1 队列ttl 单条消息ttl</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-延时交换机插件"><span class="toc-number">2.0.2.0.2.</span> <span class="toc-text">2 延时交换机插件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CustomExchange-自定义交换机，"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">CustomExchange 自定义交换机，</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两种延时方式的对比。"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">两种延时方式的对比。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两种方法共同点。"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">两种方法共同点。</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#几个坑"><span class="toc-number">2.1.</span> <span class="toc-text">几个坑</span></a></li></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/09/26/IvUxnfrh86kG7Oa.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">一朵野花</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="https://i.loli.net/2019/09/26/m2kZ3RBtKUo8xgN.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">rabbitmq的几种交换机理解实践</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-08-08<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-09-26</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ul>
<li>direct 直连<br>把消息路由到那些binding key与routing key完全匹配的Queue</li>
</ul>
<ul>
<li><p>topic  Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue<br>和direct 都需要绑定route-key<br>topic的#和<em>,# 表示和多个关键字匹配，</em> 和一个关键字匹配</p>
</li>
<li><p>header 匹配不依赖于route-key和banding-key，会根据header中的值来 匹配规则，与queue绑定的时候不需要绑定route-key，但是可以设置x-match字段为any或者all，设置为any，则只要发送消息的header和绑定的header有一个相符合，则转发给队列，如果设置为all，header必须全部符合才转发给队列 ,因为按照header来匹配</p>
</li>
<li><p>fanout<br>它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。<br>与queue绑定的时候不需要指定route-key（设置routeKey为””），发送给与fanout绑定的所有队列</p>
</li>
</ul>
<h2 id="Channel与Connection"><a href="#Channel与Connection" class="headerlink" title="Channel与Connection"></a>Channel与Connection</h2><p>Connection 是真实的TCP连接<br>Channel 是在TCP连接上虚拟的多个信道，，就像一条网线是一个Connect，，如果客户端程序是多线程的，，，有100人都要上网，为了降低成本，怎么办不可能拉100条网线吧。就给你每个人分了一个账号拨号上网，使用同一个网线。那怎么保证消息不会混乱呢？ 每个账号就是唯一的标识，这个网线上的信息都会包含账号信息，，就是某条信息是哪个账号的。这样来保证消息不会混乱。</p>
<p>从ConnectionFactory可以生成connection，connection 可以生成Channel</p>
<p>channel可以声明 交换机，队列，绑定关系。发送消息。 很多工作都是由channel完成的。</p>
<p>两个很有用的类</p>
<ul>
<li><p>RabbitAdmin   // 封装了 对Rabbitmq的管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Rabbitmq管理Bean</span><br><span class="line">@Bean</span><br><span class="line">public RabbitAdmin ampqManager(@Qualifier(&quot;connectionFactory&quot;) ConnectionFactory connectionFactory) throws IOException, TimeoutException &#123;</span><br><span class="line">    RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);</span><br><span class="line">     // 申明交换机</span><br><span class="line">    rabbitAdmin.declareExchange(getExchange());</span><br><span class="line">    // 声明队列</span><br><span class="line">    rabbitAdmin.declareQueue(getQueue());</span><br><span class="line">    // 交换机和队列的绑定</span><br><span class="line">    rabbitAdmin.declareBinding(new Binding(&quot;queue1&quot;,Binding.DestinationType.QUEUE,&quot;my_topicExchange&quot;,&quot;route-topic&quot;,null));</span><br><span class="line">    return rabbitAdmin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RabbitTemplate 简化了数据收发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)  //</span><br><span class="line">public RabbitTemplate rabbitTemplate(@Qualifier(&quot;connectionFactory&quot;) ConnectionFactory connectionFactory) &#123;</span><br><span class="line">    return new RabbitTemplate(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>数据收发使用RabbitTemplate中的现成的方法。</p>
<p>发送数据的底层是调用的basicPublish方法，<br>这个方法由三个重载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException;</span><br><span class="line"></span><br><span class="line">void basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body)</span><br><span class="line">            throws IOException;</span><br><span class="line"></span><br><span class="line">void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body)</span><br><span class="line">            throws IOException;</span><br></pre></td></tr></table></figure>

<p>共有的参数是</p>
<ul>
<li>exchange 交换机</li>
<li>routeKey 路由键</li>
<li>mandatory 设置为true  则如果过根据route-key找不到合适的队列，就调用rutern 将消息返还给发送者,如果设置为false，找不到队列直接丢弃。</li>
</ul>
<h4 id="重点总结："><a href="#重点总结：" class="headerlink" title="重点总结："></a>重点总结：</h4><h6 id="1、几种交换机的效率以及特点"><a href="#1、几种交换机的效率以及特点" class="headerlink" title="1、几种交换机的效率以及特点"></a>1、几种交换机的效率以及特点</h6><ul>
<li>fanout模式 ，在设置交换机路由绑定的时候设置，会转发给每一个和当前fanout交换机绑定的队列，routekey设置为 “”。 效率最高</li>
<li>topic模式，，即队列只接收关心的topic。 设置交换机，队列绑定的时候 灵活的routeKey。 如 topic1.*可以匹配后面一个任意字段(topic.xxx)，topic.#可以匹配任意多个字段(topic.xixi.heihei) 效率次之。 通常还是用的比较多的。消息分类处理，，发送不同类型的消息的时候指定不同的routekey 来使得其进入不同的队列。。设置监听器的时候，通过监听不同的队列，来对不同的消息进行消费。</li>
<li>direct交换机 直接连接，只有routekey完全匹配才会发送消息到对应的队列。适用于需要单独处理的消息。效率最低</li>
</ul>
<h6 id="2-消息监听的两种方式"><a href="#2-消息监听的两种方式" class="headerlink" title="2 消息监听的两种方式"></a>2 消息监听的两种方式</h6><p>1 注解监听。<br>优点：简单<br>缺点：不够灵活。效率没有监听器高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;directQueue&quot;)</span><br><span class="line">public void receiveMessage(@Payload Message message) &#123;</span><br><span class="line">    System.out.println(&quot;收到消息&quot; + message.getBody().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 设置监听器。<br>理解： 监听器就像一个容器，就像班主任站在讲台上，下面每个学生都是一个队列，班主任监听，谁说话，就让体育老师抓出去去教育一顿。</p>
<ul>
<li>教室和班主任就相当于 监听容器</li>
<li>学生 相当于放在容器中监听的队列</li>
<li>学生说话 相当于 队列消息事件</li>
<li>体育老师 相当于消费者</li>
<li>PreFechCount 相当于设置体育老师一次抓出去的学生数量。一个一个抓效率低。有三个学生说话的，一次抓三个出去一个一个处理，处理完了之后再回来继续抓。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer cmdLogMessageContainer() throws IOException, TimeoutException &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory());</span><br><span class="line">    //队列丢失，true : 队列在容器运行时被移除，则容器停止；false : 继续尝试启动消费者，每个消费者在每次恢复尝试时都会进行3次尝试（间隔5秒）</span><br><span class="line">    container.setMissingQueuesFatal(false); </span><br><span class="line">    //将队列放入监听容器</span><br><span class="line">    container.setQueues(direct1(),topic1(),topic2());</span><br><span class="line">    //监听通道打开，默认打开</span><br><span class="line">    container.setExposeListenerChannel(true);</span><br><span class="line">    //最大消费者数</span><br><span class="line">    container.setMaxConcurrentConsumers(3);</span><br><span class="line">    // 每个消费者的发生一次ack处理数量</span><br><span class="line">    container.setPrefetchCount(100);</span><br><span class="line">    //每次接收消费者数</span><br><span class="line">    container.setConcurrentConsumers(3);</span><br><span class="line">    //设置确认模式手工确认</span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.AUTO);</span><br><span class="line">    //设置监听通道，自定义监听器</span><br><span class="line">    container.setMessageListener(new DirectHandler());</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、两个类-RabbitTemplate-和RabbitAdmin"><a href="#3、两个类-RabbitTemplate-和RabbitAdmin" class="headerlink" title="3、两个类 RabbitTemplate 和RabbitAdmin"></a>3、两个类 RabbitTemplate 和RabbitAdmin</h6><p>这两个类是spring封装好的。使用RabbitMq这两个类也就足够了。<br>RabbitAdmin 来配置RabbitMq的，交换机，队列，绑定关系<br>RabbitTemplate 为我们封装了发送消息的方法，使得发送消变的更简单。</p>
<h6 id="4、一个生产者对应多个消费者"><a href="#4、一个生产者对应多个消费者" class="headerlink" title="4、一个生产者对应多个消费者"></a>4、一个生产者对应多个消费者</h6><h6 id="5、-总之-ranbbitmq四个步骤"><a href="#5、-总之-ranbbitmq四个步骤" class="headerlink" title="5、 总之 ranbbitmq四个步骤"></a>5、 总之 ranbbitmq四个步骤</h6><p>1 创建连接工厂Bean  这是第一步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ConnectionFactory connectionFactory() throws IOException, TimeoutException &#123;</span><br><span class="line">    CachingConnectionFactory factory = new CachingConnectionFactory();</span><br><span class="line">    factory.setHost(rabbitmqSetting.getHost());</span><br><span class="line">    factory.setPort(rabbitmqSetting.getPort());</span><br><span class="line">    factory.setUsername(rabbitmqSetting.getUsername());</span><br><span class="line">    factory.setPassword(rabbitmqSetting.getPassword());</span><br><span class="line">    factory.setVirtualHost(rabbitmqSetting.getVirtualHost());</span><br><span class="line">    factory.setPublisherConfirms(true);  // 设置消息回调</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 声明交换机，队列，绑定关系。。这个需要 拿到连接工厂的Bean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    // Rabbitmq管理Beangit</span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitAdmin ampqManager(@Qualifier(&quot;connectionFactory&quot;) ConnectionFactory connectionFactory) throws IOException, TimeoutException &#123;</span><br><span class="line">        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);</span><br><span class="line">        // 申明交换机</span><br><span class="line">        rabbitAdmin.declareExchange(getDirectExchange());</span><br><span class="line">        rabbitAdmin.declareExchange(getExchange());  // topic Exchange</span><br><span class="line">        rabbitAdmin.declareExchange(getFanoutExchange());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 声明队列 direct</span><br><span class="line">        rabbitAdmin.declareQueue(direct1());</span><br><span class="line">        rabbitAdmin.declareQueue(direct2());</span><br><span class="line"></span><br><span class="line">        // fanout</span><br><span class="line">        rabbitAdmin.declareQueue(fanout1());</span><br><span class="line">        rabbitAdmin.declareQueue(fanout2());</span><br><span class="line"></span><br><span class="line">        // topic</span><br><span class="line">        rabbitAdmin.declareQueue(topic1());</span><br><span class="line">        rabbitAdmin.declareQueue(topic2());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 交换机和队列的绑定</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;directQueue&quot;, Binding.DestinationType.QUEUE, &quot;my_direct&quot;, &quot;my_direct&quot;, null));</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;directQueue2&quot;, Binding.DestinationType.QUEUE, &quot;my_direct&quot;, &quot;my_direct&quot;, null));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // topic</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;topicQueue2&quot;, Binding.DestinationType.QUEUE, &quot;my_topic&quot;, &quot;my_topic.*&quot;, null));</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;topicQueue&quot;, Binding.DestinationType.QUEUE, &quot;my_topic&quot;, &quot;my_topic.q2&quot;, null));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //fanout 不用指定routekey  不能填写null  要填写&quot;&quot;  fanout 广播模式，发送给所有的队列</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;fanoutQueue1&quot;,Binding.DestinationType.QUEUE,&quot;my_fanout&quot;,&quot;&quot;,null));</span><br><span class="line"></span><br><span class="line">//        rabbitAdmin.purgeQueue(&quot;queue1&quot;);</span><br><span class="line">        return rabbitAdmin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3 添加RabbitmqTemplate<br>，需要注意如果使用回调的话，在添加RabbitTemplate这个Bean的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;如果需要在生产者需要消息发送后的回调，需要对rabbitTemplate设置ConfirmCallback对象</span><br><span class="line"> * &lt;p&gt;由于不同的生产者需要对应不同的ConfirmCallback</span><br><span class="line"> * &lt;p&gt;如果rabbitTemplate设置为单例bean</span><br><span class="line"> * &lt;p&gt;则所有的rabbitTemplate实际的ConfirmCallback为最后一次申明的ConfirmCallback</span><br><span class="line"> * &lt;p&gt;SCOPE_PROTOTYPE 每次注入或者通过上下文获取的时候，都会创建一个新的bean实例</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//Template获取连接信息，然后才可以使用Template的模板方法</span><br><span class="line">@Bean</span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)  //</span><br><span class="line">public RabbitTemplate rabbitTemplate(@Qualifier(&quot;connectionFactory&quot;) ConnectionFactory connectionFactory) &#123;</span><br><span class="line">    return new RabbitTemplate(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4 设置监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line"> public SimpleMessageListenerContainer cmdLogMessageContainer() throws IOException, TimeoutException &#123;</span><br><span class="line">     SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">     container.setConnectionFactory(connectionFactory());</span><br><span class="line">     //队列丢失，true : 队列在容器运行时被移除，则容器停止；false : 继续尝试启动消费者，每个消费者在每次恢复尝试时都会进行3次尝试（间隔5秒）</span><br><span class="line">     container.setMissingQueuesFatal(false);</span><br><span class="line">     //将队列放入监听容器</span><br><span class="line">     container.setQueues(direct1(),topic1(),topic2());</span><br><span class="line">     //监听通道打开，默认打开</span><br><span class="line">     container.setExposeListenerChannel(true);</span><br><span class="line">     //最大消费者数</span><br><span class="line">     container.setMaxConcurrentConsumers(3);</span><br><span class="line">     // 每个消费者的发生一次ack处理数量</span><br><span class="line">     container.setPrefetchCount(100);</span><br><span class="line">     //每次接收消费者数</span><br><span class="line">     container.setConcurrentConsumers(3);</span><br><span class="line">     //设置确认模式手工确认</span><br><span class="line">     container.setAcknowledgeMode(AcknowledgeMode.AUTO);</span><br><span class="line">     //设置监听通道，自定义监听器</span><br><span class="line">     container.setMessageListener(new DirectHandler());</span><br><span class="line">     return container;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5 消费者，实现自定义监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DirectHandler implements ChannelAwareMessageListener &#123;</span><br><span class="line">Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">@Async</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;监听器1收到数据&quot;+new String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息的延时"><a href="#消息的延时" class="headerlink" title="消息的延时"></a>消息的延时</h4><p>两种方式 ，</p>
<ul>
<li>1 通过设置ttl和死信交换机</li>
<li>2 使用延时交换机插件</li>
</ul>
<h6 id="1-队列ttl-单条消息ttl"><a href="#1-队列ttl-单条消息ttl" class="headerlink" title="1 队列ttl 单条消息ttl"></a>1 队列ttl 单条消息ttl</h6><ul>
<li>队列ttl的原理是 给一条普通队列设置ttl时间，以及绑定死信交换机，，在队列中的消息过期以后会路由到死信交换机，由死信交换机处理。。。死信交换机和普通交换机用法相同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 定义死信队列相关信息</span><br><span class="line"> */</span><br><span class="line">public final static String deadQueueName = &quot;dead_queue&quot;;   </span><br><span class="line">public final static String deadRoutingKey = &quot;dead_routing_key&quot;;  </span><br><span class="line">public final static String deadExchangeName = &quot;dead_exchange&quot;;   </span><br><span class="line">/**</span><br><span class="line"> * 死信队列 交换机标识符</span><br><span class="line"> */</span><br><span class="line">public static final String DEAD_LETTER_QUEUE_KEY = &quot;x-dead-letter-exchange&quot;;</span><br><span class="line">/**</span><br><span class="line"> * 死信队列交换机绑定键标识符</span><br><span class="line"> */</span><br><span class="line">public static final String DEAD_LETTER_ROUTING_KEY = &quot;x-dead-letter-routing-key&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 队列的ttl时间</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">public static final String QUEUE_MSG_TTL = &quot;x-message-ttl&quot;;</span><br><span class="line">  </span><br><span class="line">  @Bean</span><br><span class="line">Queue ttlQueue() &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(QUEUE_MSG_TTL, 20000);  //20s的存活时间   // 指定队列的存活时间20s</span><br><span class="line">    map.put(DEAD_LETTER_QUEUE_KEY, deadExchangeName);  // 指定死信交换机</span><br><span class="line">    map.put(DEAD_LETTER_ROUTING_KEY, deadRoutingKey);  // route_key 死信交换机将用这个route_key来路由消息，作用于死信交换机和死信队列之间。</span><br><span class="line">    return new Queue(&quot;ttlQueue&quot;, true, false, false, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>消息ttl是在发送消息的时候指定Properties的，此时延时队列可以指定队列的ttl，也可以不指定，如果队列和消息都有ttl， 则按照时间小的来。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  @GetMapping(&quot;/deadByMsg&quot;)</span><br><span class="line">public void deadByMessage(@RequestParam(value = &quot;time&quot;)String time) &#123;</span><br><span class="line">    logger.info(&quot;我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">    MessageProperties properties = new MessageProperties();</span><br><span class="line">    properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 持久</span><br><span class="line">    properties.setExpiration(time);   // 设置消息的ttl</span><br><span class="line">    Message msg = new Message(&quot;测试死信消息---发送消息的时候指定ttl------我是测试延时队列&quot;.getBytes(), properties);</span><br><span class="line">    provide.send(&quot;ttlExchange&quot;, &quot;ttl_key&quot;, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="2-延时交换机插件"><a href="#2-延时交换机插件" class="headerlink" title="2 延时交换机插件"></a>2 延时交换机插件</h6><p>实现消息延时发送有两种方式 </p>
<ul>
<li>一种是通过上面设置队列ttl或者单条消息的ttl，设置死信交换机和死信队列，让消息超时以后由死信交换机处理。以此达到延时目的</li>
<li>给rabbitmq安装延时插件，安装教程<a href="https://blog.csdn.net/liyongbing1122/article/details/81225761。" target="_blank" rel="noopener">https://blog.csdn.net/liyongbing1122/article/details/81225761。</a> 安装完成以后，rabbitmq就由了一种新的交换机类型”x-delayed-message”，这个交换机发送消息。可以用如下方法设置延时发送<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    // 通过插件的方式，创建 延时交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Exchange delayExchange()&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);</span><br><span class="line">        return new CustomExchange(&quot;delayExchange&quot;, &quot;x-delayed-message&quot;, true, false, args);    &#125;</span><br><span class="line"></span><br><span class="line">// 普通队列</span><br><span class="line">    @Bean</span><br><span class="line">    Queue delayQueue() &#123;</span><br><span class="line">        return new Queue(&quot;delayQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 发送消息的时候，消息头添加 x-delay字段 指定延时时间</span><br><span class="line">    @GetMapping(&quot;/delayByMsg&quot;)</span><br><span class="line">    public void delayTask(@RequestParam(value = &quot;time&quot;) Long time) &#123;</span><br><span class="line">        logger.info(&quot;我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">        MessageProperties properties = new MessageProperties();</span><br><span class="line">        properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 持久</span><br><span class="line">        String msg = &quot;测试延时发送--发送消息的时候指定延时-----&quot;;</span><br><span class="line">        // 方式1  设置 在properties 的参数里面  (超过Int范围，编译报错)</span><br><span class="line">        //properties.setDelay(time);</span><br><span class="line">        //Message message = new Message(msg.getBytes(),properties);</span><br><span class="line">        //provide.send(&quot;delayExchange&quot;, &quot;delay_key&quot;, message);</span><br><span class="line"></span><br><span class="line">        // 方式2 直接设置header    其实设置properties 就是header，本质上是一样的（超过Int范围，编译，运行都不会有异常，，但是延时不生效，队列会立即收到消息）</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;delayExchange&quot;, &quot;delay_key&quot;, msg, (message) -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setHeader(&quot;x-delay&quot;, time); //延迟9秒</span><br><span class="line">            return message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="CustomExchange-自定义交换机，"><a href="#CustomExchange-自定义交换机，" class="headerlink" title="CustomExchange 自定义交换机，"></a>CustomExchange 自定义交换机，</h5><p>在使用到延迟交换机插件的时候，，，我们使用插件新添加了一个x-delayed-message类型的交换机。  但是在Rabbitadmin中并没有这个类型的交换机。然后找到了这个CustomExchange 它和其它交换机相同，实现了AbstructExchange。 唯一的区别是没有指定type类型。type类型可以自定义，这样我们就可以通过构造方法自定义交换机的类型。</p>
<h5 id="两种延时方式的对比。"><a href="#两种延时方式的对比。" class="headerlink" title="两种延时方式的对比。"></a>两种延时方式的对比。</h5><ul>
<li>设置队列ttl，然后转发死信交换机。。处理灵活，对一类消息统一管理，适合队列里面同一类消息，ttl相同，只需要设置队列ttl就可以了。</li>
<li>设置消息的ttl，单独的某一类，个别消息的单独设置的情况。 超出ttl任然给到死信交换机</li>
<li>延迟交换机插件， 使用这个方法不需要死信交换机和死信队列，消息是在延迟时间到了之后，才会给到队列。</li>
</ul>
<h5 id="两种方法共同点。"><a href="#两种方法共同点。" class="headerlink" title="两种方法共同点。"></a>两种方法共同点。</h5><p>&nbsp;延时时间的数据类型是Int 单位ms。。在设置队列的ttl的时候，超过Int范围会编译报错。<br>设置消息的ttl大于Int。有两种情况，设置了对列的ttl。会按照队列的ttl。没有设置队列的ttl。。？？？？ 延时会不会超过int范围。。</p>
<p>延迟交换机的方式，两种方式 设置消息的properties的Delay参数，延时超过int编译报错，，直接设置header，编译，运行均没有异常，只是超过int延时不生效。</p>
<h3 id="几个坑"><a href="#几个坑" class="headerlink" title="几个坑"></a>几个坑</h3><ul>
<li>jiva这边修改了交换机的配置，然后需要在rabbitmq上先把exchange 解绑，然后再运行否则原先的配置不会删除，新的配置也会添加，导致都会生效。</li>
<li>在调试延时队列的时候，springboot启动报错。有可能的原因是，修改了rabbitmq的Config， 修改了队列的ttl。 然后再rabbitmq的管理后台没有删除队列，导致运行时候会添加相同的队列，但是ttl不同，造成冲突。。。解决办法。。如果修改了队列配置，交换机配置。。。在启动sprigboot之前要先删除掉原来配置，，，因为你启动的时候会再去声明交换机和队列。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">一朵野花</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/08/08/rabbitmq的几种交换机理解和实践/">http://yoursite.com/2019/08/08/rabbitmq的几种交换机理解和实践/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/rabbitmq/">rabbitmq    </a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/09/26/IvUxnfrh86kG7Oa.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/19/springCloud的hystrix和状态监控/"><img class="prev_cover lozad" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1299721426,436795974&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>spring Cloud 的Hystrix</span></div></a></div><div class="next-post pull-right"><a href="/2019/07/27/Zookeeper分布式锁/"><img class="next_cover lozad" data-src="https://i.loli.net/2019/09/26/b5mJN3zxIualUpP.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Zookeeper的分布式锁</span></div></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By 一朵野花</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">简体中文</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#交换机"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">交换机</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Channel与Connection"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Channel与Connection</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#重点总结："><span class="toc_mobile_items-number">2.0.1.</span> <span class="toc_mobile_items-text">重点总结：</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#1、几种交换机的效率以及特点"><span class="toc_mobile_items-number">2.0.1.0.1.</span> <span class="toc_mobile_items-text">1、几种交换机的效率以及特点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#2-消息监听的两种方式"><span class="toc_mobile_items-number">2.0.1.0.2.</span> <span class="toc_mobile_items-text">2 消息监听的两种方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#3、两个类-RabbitTemplate-和RabbitAdmin"><span class="toc_mobile_items-number">2.0.1.0.3.</span> <span class="toc_mobile_items-text">3、两个类 RabbitTemplate 和RabbitAdmin</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#4、一个生产者对应多个消费者"><span class="toc_mobile_items-number">2.0.1.0.4.</span> <span class="toc_mobile_items-text">4、一个生产者对应多个消费者</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#5、-总之-ranbbitmq四个步骤"><span class="toc_mobile_items-number">2.0.1.0.5.</span> <span class="toc_mobile_items-text">5、 总之 ranbbitmq四个步骤</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#消息的延时"><span class="toc_mobile_items-number">2.0.2.</span> <span class="toc_mobile_items-text">消息的延时</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#1-队列ttl-单条消息ttl"><span class="toc_mobile_items-number">2.0.2.0.1.</span> <span class="toc_mobile_items-text">1 队列ttl 单条消息ttl</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#2-延时交换机插件"><span class="toc_mobile_items-number">2.0.2.0.2.</span> <span class="toc_mobile_items-text">2 延时交换机插件</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#CustomExchange-自定义交换机，"><span class="toc_mobile_items-number">2.0.2.1.</span> <span class="toc_mobile_items-text">CustomExchange 自定义交换机，</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#两种延时方式的对比。"><span class="toc_mobile_items-number">2.0.2.2.</span> <span class="toc_mobile_items-text">两种延时方式的对比。</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#两种方法共同点。"><span class="toc_mobile_items-number">2.0.2.3.</span> <span class="toc_mobile_items-text">两种方法共同点。</span></a></li></ol><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#几个坑"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">几个坑</span></a></li></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script></body></html>